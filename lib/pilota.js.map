{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///pilota.js","webpack:///webpack/bootstrap e9ddcf2e9874593a6c4f","webpack:///./~/rxjs/Subscriber.js","webpack:///./~/rxjs/util/root.js","webpack:///./~/rxjs/Observable.js","webpack:///./~/rxjs/Subscription.js","webpack:///./src/util.js","webpack:///./~/rxjs/symbol/rxSubscriber.js","webpack:///./~/rxjs/symbol/observable.js","webpack:///./~/rxjs/util/errorObject.js","webpack:///./~/rxjs/util/isArray.js","webpack:///./~/rxjs/util/isFunction.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/cmdBus.js","webpack:///./src/submodelCmd.js","webpack:///./src/dispatcher.js","webpack:///./src/resolver.js","webpack:///./~/rxjs/InnerSubscriber.js","webpack:///./~/rxjs/Observer.js","webpack:///./~/rxjs/OuterSubscriber.js","webpack:///./~/rxjs/Scheduler.js","webpack:///./~/rxjs/Subject.js","webpack:///./~/rxjs/SubjectSubscription.js","webpack:///./~/rxjs/add/operator/filter.js","webpack:///./~/rxjs/add/operator/map.js","webpack:///./~/rxjs/add/operator/withLatestFrom.js","webpack:///./~/rxjs/operator/filter.js","webpack:///./~/rxjs/operator/map.js","webpack:///./~/rxjs/operator/withLatestFrom.js","webpack:///./~/rxjs/scheduler/Action.js","webpack:///./~/rxjs/scheduler/AsyncAction.js","webpack:///./~/rxjs/scheduler/AsyncScheduler.js","webpack:///./~/rxjs/scheduler/async.js","webpack:///./~/rxjs/symbol/iterator.js","webpack:///./~/rxjs/util/ObjectUnsubscribedError.js","webpack:///./~/rxjs/util/UnsubscriptionError.js","webpack:///./~/rxjs/util/isObject.js","webpack:///./~/rxjs/util/isPromise.js","webpack:///./~/rxjs/util/subscribeToResult.js","webpack:///./~/rxjs/util/toSubscriber.js","webpack:///./~/rxjs/util/tryCatch.js","webpack:///./src/pilota.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","__extends","b","__","constructor","create","isFunction_1","Subscription_1","Observer_1","rxSubscriber_1","Subscriber","_super","destinationOrNext","error","complete","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","arguments","length","destination","empty","add","SafeSubscriber","$$rxSubscriber","next","subscriber","_next","err","_error","_complete","unsubscribe","closed","Subscription","_parent","observerOrNext","context","isFunction","bind","_context","__tryOrSetError","__tryOrUnsub","fn","parent","_unsubscribe","global","objectTypes","boolean","function","number","string","undefined","self","window","freeGlobal","root_1","toSubscriber_1","observable_1","Observable","subscribe","_isScalar","_subscribe","lift","operator","observable","source","sink","toSubscriber","forEach","PromiseCtor","_this","Rx","config","Promise","Error","resolve","reject","subscription","$$observable","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_a","_subscriptions","trial","tryCatch","errorObject","push","e","isArray","index","len","sub","isObject","UnsubscriptionError","concat","teardown","EMPTY","remove","subscriptions","subscriptionIndex","indexOf","splice","precondition","x","msg","subscribeLog","observable$","v","console","log","Symbol","for","getSymbolObservable","Array","g","Function","eval","newCmdBus$","state$","dispatch","cmdBus$","_Subject","Subject","_async","async","_util","resolver","_resolver","newObjectResolver","_dispatcher","newDispatcher","addHandler","on","map","cmd","withLatestFrom","state","filter","logCmdBus","submodelCmd","result","assign","_len","props","_key","cmdObject","mapping","handlers","cmdName","handler","Subscriber_1","InnerSubscriber","outerValue","outerIndex","notifyNext","notifyError","notifyComplete","OuterSubscriber","apply","innerValue","innerIndex","innerSub","Scheduler","SchedulerAction","now","schedule","work","delay","Date","Observable_1","ObjectUnsubscribedError_1","SubjectSubscription_1","SubjectSubscriber","observers","hasError","thrownError","subject","AnonymousSubject","ObjectUnsubscribedError","copy","slice","SubjectSubscription","asObservable","subscriberIndex","filter_1","map_1","withLatestFrom_1","predicate","thisArg","FilterOperator","FilterSubscriber","count","project","TypeError","MapOperator","MapSubscriber","args","_i","pop","observables","WithLatestFromOperator","OuterSubscriber_1","subscribeToResult_1","WithLatestFromSubscriber","toRespond","values","subscribeToResult","found","_tryProject","Action","scheduler","Action_1","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","actions","Scheduler_1","AsyncScheduler","active","scheduled","action","shift","AsyncAction_1","AsyncScheduler_1","iterator","$$iterator","Set","Map","keys","getOwnPropertyNames","key","stack","message","toString","join","isPromise","then","outerSubscriber","InnerSubscriber_1","isPromise_1","setTimeout","iterator_1","item","done","obs","nextOrObserver","tryCatcher","tryCatchTarget","_cmdBus","_submodelCmd","default"],"mappings":"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","file":"pilota.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pilota\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pilota\"] = factory();\n\telse\n\t\troot[\"pilota\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pilota\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pilota\"] = factory();\n\telse\n\t\troot[\"pilota\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 39);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = __webpack_require__(9);\nvar Subscription_1 = __webpack_require__(3);\nvar Observer_1 = __webpack_require__(16);\nvar rxSubscriber_1 = __webpack_require__(5);\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar root_1 = __webpack_require__(1);\nvar toSubscriber_1 = __webpack_require__(37);\nvar observable_1 = __webpack_require__(6);\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar isArray_1 = __webpack_require__(8);\nvar isObject_1 = __webpack_require__(34);\nvar isFunction_1 = __webpack_require__(9);\nvar tryCatch_1 = __webpack_require__(38);\nvar errorObject_1 = __webpack_require__(7);\nvar UnsubscriptionError_1 = __webpack_require__(33);\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.precondition = precondition;\nexports.isFunction = isFunction;\nexports.subscribeLog = subscribeLog;\nfunction precondition(x, msg) {\n  if (!x) throw msg;\n}\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n\nfunction subscribeLog(observable$, name) {\n  observable$.subscribe(function (v) {\n    global.console.log(name + '.next:', v);\n  }, function (v) {\n    global.console.log(name + '.error:', v);\n  }, function (v) {\n    global.console.log(name + '.complete:', v);\n  });\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar root_1 = __webpack_require__(1);\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar root_1 = __webpack_require__(1);\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.newCmdBus$ = newCmdBus$;\nexports.logCmdBus = logCmdBus;\n\nvar _Subject = __webpack_require__(19);\n\n__webpack_require__(22);\n\n__webpack_require__(21);\n\n__webpack_require__(23);\n\nvar _async = __webpack_require__(30);\n\nvar _util = __webpack_require__(4);\n\nvar _resolver = __webpack_require__(14);\n\nvar _dispatcher = __webpack_require__(13);\n\n/*\n Bus to dispatch and apply commands to the state stream.\n\n state$ -- an Observable and Observer\n\n dispatch -- One of the following:\n\n * null or undefined -- returned cmdBus does no dispatching in the given\n state. The caller can add command handlers calling `addHandler`.\n\n * object -- a map of command names to handling functions\n\n * a dispatcher function -- a function that will handle the commands. The signature\n is `(state, cmd) => state`. The name of the command is available as `name` property.\n\n */\n\nfunction newCmdBus$(state$, dispatch) {\n\n  var cmdBus$ = new _Subject.Subject(_async.async);\n\n  if ((0, _util.isFunction)(dispatch)) {\n    cmdBus$.dispatch = dispatch;\n  } else {\n    var resolver = (0, _resolver.newObjectResolver)(dispatch);\n    cmdBus$.dispatch = (0, _dispatcher.newDispatcher)(resolver);\n    cmdBus$.addHandler = resolver.addHandler;\n    cmdBus$.on = cmdBus$.addHandler; // alias\n  }\n\n  cmdBus$.map(function (cmd) {\n    return typeof cmd == 'string' ? { name: cmd } : cmd;\n  }).withLatestFrom(state$, function (cmd, state) {\n    return cmdBus$.dispatch(state, cmd);\n  }).filter(function (x) {\n    return x !== undefined;\n  }).subscribe(state$);\n\n  return cmdBus$;\n}\n\nfunction logCmdBus(cmdBus$) {\n  (0, _util.subscribeLog)(cmdBus$, 'cmdBus$');\n}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.submodelCmd = submodelCmd;\nfunction submodelCmd(property, fn) {\n  if (typeof fn != 'undefined') {\n    return function (state) {\n      var result = Object.assign({}, state);\n\n      for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        props[_key - 1] = arguments[_key];\n      }\n\n      result[property] = fn.apply(undefined, [state[property]].concat(props));\n      return result;\n    };\n  } else {\n    // If no property is provided, then we return a partially applied fn.\n    fn = property;\n    return function (property) {\n      return submodelCmd(property, fn);\n    };\n  }\n}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.newDispatcher = newDispatcher;\n\nvar _util = __webpack_require__(4);\n\n/*\n The Dispatcher is responsible for dispatching the event to all EventManagers.\n */\nfunction newDispatcher(resolver) {\n  (0, _util.precondition)(resolver, 'resolver is required for a dispatcher');\n  (0, _util.precondition)((0, _util.isFunction)(resolver), 'resolver must be a function');\n\n  var dispatch = function dispatch(state, cmdObject) {\n    var fn = resolver(cmdObject.name);\n    return fn ? fn.call(cmdObject, state, cmdObject) : undefined;\n  };\n  dispatch.addHandler = resolver.addHandler; // OK if `resolver.addHandler` is undefined\n  return dispatch;\n}\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.newObjectResolver = newObjectResolver;\n\nvar _util = __webpack_require__(4);\n\nfunction newObjectResolver(mapping) {\n\n  var handlers = Object.assign({}, mapping);\n\n  var resolver = function resolver(name) {\n    return handlers[name] || handlers['*'];\n  };\n\n  resolver.addHandler = function (cmdName, handler) {\n    (0, _util.precondition)(cmdName, 'requires a command name');\n    (0, _util.precondition)((0, _util.isFunction)(handler), 'requires a projection function');\n    handlers[cmdName] = handler;\n  };\n\n  return resolver;\n} /*\n   Uses an object to map commands to handler functions. What is an\n   object anyway?\n  \n   Returns a function that can be used by a dispatcher,  with\n   the signature:\n  \n   ```\n   (String) => Fn(State, CmdObject)\n   ```\n   */\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = __webpack_require__(2);\nvar Subscriber_1 = __webpack_require__(0);\nvar Subscription_1 = __webpack_require__(3);\nvar ObjectUnsubscribedError_1 = __webpack_require__(32);\nvar SubjectSubscription_1 = __webpack_require__(20);\nvar rxSubscriber_1 = __webpack_require__(5);\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(3);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar Observable_1 = __webpack_require__(2);\nvar filter_1 = __webpack_require__(24);\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar Observable_1 = __webpack_require__(2);\nvar map_1 = __webpack_require__(25);\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar Observable_1 = __webpack_require__(2);\nvar withLatestFrom_1 = __webpack_require__(26);\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = __webpack_require__(0);\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = __webpack_require__(17);\nvar subscribeToResult_1 = __webpack_require__(36);\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {Observable} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\n/* tslint:enable:max-line-length */\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = __webpack_require__(3);\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = __webpack_require__(1);\nvar Action_1 = __webpack_require__(27);\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.delay = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = __webpack_require__(18);\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar AsyncAction_1 = __webpack_require__(28);\nvar AsyncScheduler_1 = __webpack_require__(29);\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar root_1 = __webpack_require__(1);\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.iterator) {\n        exports.$$iterator = Symbol.iterator;\n    }\n    else if (typeof Symbol.for === 'function') {\n        exports.$$iterator = Symbol.for('iterator');\n    }\n}\nelse {\n    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n        // Bug for mozilla version\n        exports.$$iterator = '@@iterator';\n    }\n    else if (root_1.root.Map) {\n        // es6-shim specific logic\n        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n                exports.$$iterator = key;\n                break;\n            }\n        }\n    }\n    else {\n        exports.$$iterator = '@@iterator';\n    }\n}\n//# sourceMappingURL=iterator.js.map\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar root_1 = __webpack_require__(1);\nvar isArray_1 = __webpack_require__(8);\nvar isPromise_1 = __webpack_require__(35);\nvar Observable_1 = __webpack_require__(2);\nvar iterator_1 = __webpack_require__(31);\nvar InnerSubscriber_1 = __webpack_require__(15);\nvar observable_1 = __webpack_require__(6);\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar Subscriber_1 = __webpack_require__(0);\nvar rxSubscriber_1 = __webpack_require__(5);\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber();\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\nvar errorObject_1 = __webpack_require__(7);\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _cmdBus = __webpack_require__(11);\n\nvar _submodelCmd = __webpack_require__(12);\n\nexports.default = {\n  newCmdBus$: _cmdBus.newCmdBus$,\n  logCmdBus: _cmdBus.logCmdBus,\n  submodelCmd: _submodelCmd.submodelCmd\n};\nmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// pilota.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 39);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e9ddcf2e9874593a6c4f","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscriber.js\n// module id = 0\n// module chunks = 0","\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/root.js\n// module id = 1\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar observable_1 = require('./symbol/observable');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observable.js\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.closed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.closed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subscription.js\n// module id = 3\n// module chunks = 0","export function precondition(x, msg) {\n  if (!x) throw msg\n}\n\nexport function isFunction(x) {\n  return typeof x === 'function'\n}\n\nexport function subscribeLog(observable$, name) {\n  observable$.subscribe(\n    function(v) {\n      global.console.log(`${name}.next:`, v)\n    },\n    function(v) {\n      global.console.log(`${name}.error:`, v)\n    },\n    function(v) {\n      global.console.log(`${name}.complete:`, v)\n    }\n  )\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/rxSubscriber.js\n// module id = 5\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/observable.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/errorObject.js\n// module id = 7\n// module chunks = 0","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isArray.js\n// module id = 8\n// module chunks = 0","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isFunction.js\n// module id = 9\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 10\n// module chunks = 0","import {Subject} from 'rxjs/Subject'\nimport 'rxjs/add/operator/map'\nimport 'rxjs/add/operator/filter'\nimport 'rxjs/add/operator/withLatestFrom'\nimport {async} from 'rxjs/scheduler/async'\nimport {subscribeLog, isFunction} from './util.js'\nimport {newObjectResolver} from './resolver.js'\nimport {newDispatcher} from './dispatcher.js'\n\n/*\n Bus to dispatch and apply commands to the state stream.\n\n state$ -- an Observable and Observer\n\n dispatch -- One of the following:\n\n * null or undefined -- returned cmdBus does no dispatching in the given\n state. The caller can add command handlers calling `addHandler`.\n\n * object -- a map of command names to handling functions\n\n * a dispatcher function -- a function that will handle the commands. The signature\n is `(state, cmd) => state`. The name of the command is available as `name` property.\n\n */\n\nexport function newCmdBus$(state$, dispatch) {\n\n  const cmdBus$ = new Subject(async)\n\n  if (isFunction(dispatch)) {\n    cmdBus$.dispatch = dispatch\n  } else {\n    const resolver     = newObjectResolver(dispatch)\n    cmdBus$.dispatch   = newDispatcher(resolver)\n    cmdBus$.addHandler = resolver.addHandler\n    cmdBus$.on         = cmdBus$.addHandler // alias\n  }\n\n  cmdBus$\n      .map((cmd) => typeof cmd == 'string' ? {name: cmd} : cmd)\n      .withLatestFrom(state$, (cmd, state) => cmdBus$.dispatch(state, cmd))\n      .filter(x => x !== undefined)\n      .subscribe(state$)\n\n  return cmdBus$\n}\n\nexport function logCmdBus(cmdBus$) {\n  subscribeLog(cmdBus$, 'cmdBus$')\n}\n\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/cmdBus.js","export function submodelCmd(property, fn) {\n  if (typeof fn != 'undefined') {\n    return function(state, ...props) {\n      const result     = Object.assign({}, state)\n      result[property] = fn(state[property], ...props)\n      return result\n    }\n  } else {\n    // If no property is provided, then we return a partially applied fn.\n    fn = property\n    return function(property) {\n      return submodelCmd(property, fn)\n    }\n  }\n}\n\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/submodelCmd.js","import {precondition, isFunction} from './util.js'\n\n\n/*\n The Dispatcher is responsible for dispatching the event to all EventManagers.\n */\nexport function newDispatcher(resolver) {\n  precondition(resolver, 'resolver is required for a dispatcher')\n  precondition(isFunction(resolver), 'resolver must be a function')\n\n  const dispatch      = function(state, cmdObject) {\n    const fn = resolver(cmdObject.name)\n    return fn ? fn.call(cmdObject, state, cmdObject) : undefined\n  }\n  dispatch.addHandler = resolver.addHandler // OK if `resolver.addHandler` is undefined\n  return dispatch\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/dispatcher.js","/*\n Uses an object to map commands to handler functions. What is an\n object anyway?\n\n Returns a function that can be used by a dispatcher,  with\n the signature:\n\n ```\n (String) => Fn(State, CmdObject)\n ```\n */\n\nimport { precondition, isFunction } from './util.js'\n\nexport function newObjectResolver(mapping) {\n\n  const handlers = Object.assign({}, mapping)\n\n  const resolver = function(name) {\n    return handlers[name] || handlers['*']\n  }\n\n  resolver.addHandler = function(cmdName, handler) {\n    precondition(cmdName, 'requires a command name')\n    precondition(isFunction(handler), 'requires a projection function')\n    handlers[cmdName] = handler\n  }\n\n  return resolver\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/resolver.js","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/InnerSubscriber.js\n// module id = 15\n// module chunks = 0","\"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Observer.js\n// module id = 16\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/OuterSubscriber.js\n// module id = 17\n// module chunks = 0","\"use strict\";\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nvar Scheduler = (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) { now = Scheduler.now; }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) { delay = 0; }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\nexports.Scheduler = Scheduler;\n//# sourceMappingURL=Scheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Scheduler.js\n// module id = 18\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('./Observable');\nvar Subscriber_1 = require('./Subscriber');\nvar Subscription_1 = require('./Subscription');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/Subject.js\n// module id = 19\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('./Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/SubjectSubscription.js\n// module id = 20\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar filter_1 = require('../../operator/filter');\nObservable_1.Observable.prototype.filter = filter_1.filter;\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/filter.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/map.js\n// module id = 22\n// module chunks = 0","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar withLatestFrom_1 = require('../../operator/withLatestFrom');\nObservable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/add/operator/withLatestFrom.js\n// module id = 23\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctKey}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nfunction filter(predicate, thisArg) {\n    return this.lift(new FilterOperator(predicate, thisArg));\n}\nexports.filter = filter;\nvar FilterOperator = (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar FilterSubscriber = (function (_super) {\n    __extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        _super.call(this, destination);\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n        this.count = 0;\n        this.predicate = predicate;\n    }\n    // the try catch block below is left specifically for\n    // optimization and perf reasons. a tryCatcher is not necessary here.\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=filter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/filter.js\n// module id = 24\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/map.js\n// module id = 25\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var result = clicks.withLatestFrom(timer);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link combineLatest}\n *\n * @param {Observable} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Function} [project] Projection function for combining values\n * together. Receives all values in order of the Observables passed, where the\n * first parameter is a value from the source Observable. (e.g.\n * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n * passed, arrays will be emitted on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method withLatestFrom\n * @owner Observable\n */\nfunction withLatestFrom() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i - 0] = arguments[_i];\n    }\n    var project;\n    if (typeof args[args.length - 1] === 'function') {\n        project = args.pop();\n    }\n    var observables = args;\n    return this.lift(new WithLatestFromOperator(observables, project));\n}\nexports.withLatestFrom = withLatestFrom;\n/* tslint:enable:max-line-length */\nvar WithLatestFromOperator = (function () {\n    function WithLatestFromOperator(observables, project) {\n        this.observables = observables;\n        this.project = project;\n    }\n    WithLatestFromOperator.prototype.call = function (subscriber, source) {\n        return source._subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n    };\n    return WithLatestFromOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar WithLatestFromSubscriber = (function (_super) {\n    __extends(WithLatestFromSubscriber, _super);\n    function WithLatestFromSubscriber(destination, observables, project) {\n        _super.call(this, destination);\n        this.observables = observables;\n        this.project = project;\n        this.toRespond = [];\n        var len = observables.length;\n        this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            this.toRespond.push(i);\n        }\n        for (var i = 0; i < len; i++) {\n            var observable = observables[i];\n            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n        }\n    }\n    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        var toRespond = this.toRespond;\n        if (toRespond.length > 0) {\n            var found = toRespond.indexOf(outerIndex);\n            if (found !== -1) {\n                toRespond.splice(found, 1);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype.notifyComplete = function () {\n        // noop\n    };\n    WithLatestFromSubscriber.prototype._next = function (value) {\n        if (this.toRespond.length === 0) {\n            var args = [value].concat(this.values);\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                this.destination.next(args);\n            }\n        }\n    };\n    WithLatestFromSubscriber.prototype._tryProject = function (args) {\n        var result;\n        try {\n            result = this.project.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return WithLatestFromSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=withLatestFrom.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/operator/withLatestFrom.js\n// module id = 26\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('../Subscription');\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        _super.call(this);\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        return this;\n    };\n    return Action;\n}(Subscription_1.Subscription));\nexports.Action = Action;\n//# sourceMappingURL=Action.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/Action.js\n// module id = 27\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar root_1 = require('../util/root');\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        _super.call(this, scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // clear the interval id\n        return root_1.root.clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.delay = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n    };\n    return AsyncAction;\n}(Action_1.Action));\nexports.AsyncAction = AsyncAction;\n//# sourceMappingURL=AsyncAction.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncAction.js\n// module id = 28\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Scheduler_1 = require('../Scheduler');\nvar AsyncScheduler = (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        _super.apply(this, arguments);\n        this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        this.scheduled = undefined;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler_1.Scheduler));\nexports.AsyncScheduler = AsyncScheduler;\n//# sourceMappingURL=AsyncScheduler.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/AsyncScheduler.js\n// module id = 29\n// module chunks = 0","\"use strict\";\nvar AsyncAction_1 = require('./AsyncAction');\nvar AsyncScheduler_1 = require('./AsyncScheduler');\nexports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n//# sourceMappingURL=async.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/scheduler/async.js\n// module id = 30\n// module chunks = 0","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.iterator) {\n        exports.$$iterator = Symbol.iterator;\n    }\n    else if (typeof Symbol.for === 'function') {\n        exports.$$iterator = Symbol.for('iterator');\n    }\n}\nelse {\n    if (root_1.root.Set && typeof new root_1.root.Set()['@@iterator'] === 'function') {\n        // Bug for mozilla version\n        exports.$$iterator = '@@iterator';\n    }\n    else if (root_1.root.Map) {\n        // es6-shim specific logic\n        var keys = Object.getOwnPropertyNames(root_1.root.Map.prototype);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (key !== 'entries' && key !== 'size' && root_1.root.Map.prototype[key] === root_1.root.Map.prototype['entries']) {\n                exports.$$iterator = key;\n                break;\n            }\n        }\n    }\n    else {\n        exports.$$iterator = '@@iterator';\n    }\n}\n//# sourceMappingURL=iterator.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/symbol/iterator.js\n// module id = 31\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/ObjectUnsubscribedError.js\n// module id = 32\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/UnsubscriptionError.js\n// module id = 33\n// module chunks = 0","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isObject.js\n// module id = 34\n// module chunks = 0","\"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/isPromise.js\n// module id = 35\n// module chunks = 0","\"use strict\";\nvar root_1 = require('./root');\nvar isArray_1 = require('./isArray');\nvar isPromise_1 = require('./isPromise');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    if (isArray_1.isArray(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new Error('invalid observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        destination.error(new TypeError('unknown type returned'));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/subscribeToResult.js\n// module id = 36\n// module chunks = 0","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber();\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/toSubscriber.js\n// module id = 37\n// module chunks = 0","\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rxjs/util/tryCatch.js\n// module id = 38\n// module chunks = 0","import { newCmdBus$, logCmdBus } from './cmdBus.js'\nimport { submodelCmd } from './submodelCmd.js'\n\nexport default {\n  newCmdBus$,\n  logCmdBus,\n  submodelCmd\n}\n\n\n// WEBPACK FOOTER //\n// ./src/pilota.js"],"sourceRoot":""}